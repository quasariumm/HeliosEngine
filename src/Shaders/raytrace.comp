#version 460 core
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_ARB_shading_language_include : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D OutTexture;
uniform uint ScreenWidth;
uniform uint ScreenHeight;

uniform mat4 CamToWorld;
uniform vec3 ViewParams;

uniform bool Accumulate;

uniform int Frame = 0;

const float PI = 3.14159265357f;

struct Ray
{
	vec3 origin;
	vec3 dir;
	vec3 invDir;
};

struct RayTracingMaterial
{
	vec3 diffuseColor;
	vec3 specularColor;
	float shininess;
	float specularProbability;

	vec3 emissionColor;
	float emissionStrength;

	float refractionProbability;
	float refractionCoefficient;
};

struct RayHitInfo
{
	bool didHit;
	float dst;
	vec3 hitPoint;
	vec3 normal;
	RayTracingMaterial material;
};


vec3 GetBRDF(inout RayTracingMaterial material)
{
	return material.diffuseColor;
}


vec3 GetPDF(inout RayTracingMaterial material)
{
	return vec3(PI);
}


vec3 Trace(Ray ray, uint seed)
{
	vec3 incommingLight = vec3(0);
	vec3 rayColor = vec3(1);

	return ray.dir;
}

void main()
{
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

	if (texelCoord.x >= ScreenWidth || texelCoord.y >= ScreenHeight)
		return;

	vec2 tc = vec2(texelCoord.x / float(ScreenWidth), texelCoord.y / float(ScreenHeight));

	Ray ray;

	vec3 focusDirLocal = vec3((tc - 0.5) * ViewParams.xy, ViewParams.z);
	ray.dir = (CamToWorld * vec4(focusDirLocal, 1.0)).xyz;
	ray.origin = CamToWorld[3].xyz;

	// Generate a random number based on the focus dir and the time
	// Since the x and y of the texture coordinate give an 'index', I use those
	uint seed = uint(floor(
		tc.y * ScreenHeight * ScreenWidth
		+ tc.x * ScreenWidth)
		* Frame
	);

	vec4 pixel = vec4(Trace(ray, seed), 1.0);

	imageStore(OutTexture, texelCoord, pixel);
}
