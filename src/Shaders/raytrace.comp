#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D OutTexture;
uniform uint ScreenWidth;
uniform uint ScreenHeight;

uniform mat4 CamToWorld;
uniform vec3 ViewParams;

const float PI = 3.14159265357f;
const float TWO_PI = 2.0 * PI;



struct RayTracingMaterial
{
	vec3 diffuseColor;
	vec3 specularColor;
	float shininess;
	float specularProbability;

	vec3 emissionColor;
	float emissionStrength;

	float refractionProbability;
	float refractionCoefficient;
};

const RayTracingMaterial defaultMaterial = RayTracingMaterial(vec3(0.0), vec3(0.0), 0.0, 1.0, vec3(0.0), 0.0, 0.0, 1.0);

struct RayHitInfo
{
	bool didHit;
	float dst;
	vec3 hitPoint;
	vec3 normal;
	RayTracingMaterial material;
};

const RayHitInfo defaultHitInfo = RayHitInfo( false, 1e30, vec3(0.0), vec3(0.0), defaultMaterial );


struct Ray
{
	vec3 origin;
	vec3 dir;
	vec3 invDir;
};

struct Sphere
{
	vec3 center;
	float radius;
	RayTracingMaterial material;
};
#define SPHERES_MAX 16
uniform Sphere Spheres[SPHERES_MAX];
uniform int NumSpheres = 0;

const Sphere testSphere = Sphere(vec3(0.0), 1.0, defaultMaterial);

RayHitInfo RaySphere(Ray ray, Sphere sphere)
{
	// Thanks for the code, Sebastian Lague
	RayHitInfo hitInfo = defaultHitInfo;
	hitInfo.material = sphere.material;

	vec3 difference = sphere.center - ray.origin;
	float a = dot(ray.dir, ray.dir);
	float b = -2.0 * dot(difference, ray.dir);
	float c = dot(difference, difference) - sphere.radius * sphere.radius;
	float disc = b*b - 4.0*a*c;
	if (disc < 0.0)
	{
		// Ray truly misses the sphere
		return hitInfo;
	}

	float sqrtDisc = sqrt(disc);
	// Distance to nearest intersection point (from quadratic formula)
	float dst = (-b - sqrtDisc) / (2.0 * a);

	// Ignore intersections that occur behind the ray
	if (dst >= 0.0)
	{
		hitInfo.didHit = true;
		hitInfo.dst = dst;
		hitInfo.hitPoint = ray.origin + ray.dir * dst;
		hitInfo.normal = normalize(hitInfo.hitPoint - sphere.center);
		return hitInfo;
	}

	float dst2 = (-b + sqrtDisc) / (2.0 * a);

	if (dst2 >= 0.0)
	{
		hitInfo.didHit = true;
		hitInfo.dst = dst2;
		hitInfo.hitPoint = ray.origin + ray.dir * dst2;
		hitInfo.normal = normalize(hitInfo.hitPoint - sphere.center);
		return hitInfo;
	}

	return hitInfo;
}

RayHitInfo RayCollision(Ray ray)
{
	RayHitInfo closest = defaultHitInfo;
	closest.didHit = false;
	closest.dst = 1e30;
	for (int i = 0; i < NumSpheres; ++i)
	{
		RayHitInfo sphereInfo = RaySphere(ray, Spheres[i]);
		if (sphereInfo.didHit
		&& (sphereInfo.dst < closest.dst))
		{
			closest = sphereInfo;
		}
	}
	return closest;
}

/*
	Materials
*/

vec3 GetBRDF(inout RayTracingMaterial material)
{
	return material.diffuseColor;
}


vec3 GetPDF(inout RayTracingMaterial material)
{
	return vec3(1.0);
}

/*
	Random
*/

uint Randomise(inout uint seed)
{
	seed = seed * 747796405u + 2891336453u;
	seed = ((seed >> ((seed >> 28u) + 4u)) ^ seed) * 277803737u;
	seed = (seed >> 22u) ^ seed;
	return seed;
}

float RandomFloat(inout uint seed)
{
	return Randomise(seed) / 4294967295.f;
}

// Random value in normal distribution (with mean=0 and sd=1)
float RandomValueNormalDistribution(inout uint seed)
{
	// Thanks to https://stackoverflow.com/a/6178290
	float theta = TWO_PI * RandomFloat(seed);
	float rho = sqrt(-2 * log(RandomFloat(seed)));
	return rho * cos(theta);
}


// Calculate a random direction
vec3 RandomDirection(inout uint seed)
{
	// Thanks to https://math.stackexchange.com/a/1585996
	float x = RandomValueNormalDistribution(seed);
	float y = RandomValueNormalDistribution(seed);
	float z = RandomValueNormalDistribution(seed);
	return normalize(vec3(x, y, z));
}


vec2 RandomPointInCircle(inout uint seed)
{
	float angle = RandomFloat(seed) * TWO_PI;
	vec2 pointOnCircle = vec2(cos(angle), sin(angle));
	return pointOnCircle * sqrt(RandomFloat(seed));
}

/*
	Bounces
*/

void LambertianBounce(inout Ray ray, inout uint seed, in RayHitInfo info)
{
	ray.dir = normalize(info.normal + RandomDirection(seed));
	ray.invDir = 1.0 / ray.dir;
}

/*
	Lighting
*/

struct DirectionalLight
{
	vec3 color;
	vec3 direction;
	float intensity;
};

vec3 SampleDirectionalLight(DirectionalLight light, vec3 intersection, vec3 normal)
{
	float overlap = dot(-light.direction, normal);
	if (overlap < 0.0)
	{
		return vec3(0.0);
	}
	return light.color * light.intensity * overlap;
}

const DirectionalLight sun = DirectionalLight(vec3(0.9), normalize(vec3(1.0, -1.0, 0.0)), 1.0);

vec3 Trace(Ray ray, uint seed)
{
	vec3 incommingLight = vec3(0);
	vec3 rayColor = vec3(1);

	for (int i = 0; i <= 3; ++i)
	{
		RayHitInfo info = RayCollision(ray);

		if (info.didHit)
		{
			vec3 BRDF = GetBRDF(info.material);
			vec3 PDF = GetPDF(info.material);

			vec3 emittance = info.material.emissionColor * info.material.emissionStrength;

			vec3 light = SampleDirectionalLight(sun, info.hitPoint, info.normal);

			incommingLight += (emittance + BRDF * light * PDF) * rayColor;

			rayColor *= info.material.diffuseColor * light;

			ray.origin = info.hitPoint + 0.0001 * info.normal;
			LambertianBounce(ray, seed, info);
		}
		else
		{
			incommingLight += rayColor * vec3(0.2, 0.2, 0.4);
			break;
		}
	}

	return incommingLight;
}

void main()
{
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

	if (texelCoord.x >= ScreenWidth || texelCoord.y >= ScreenHeight)
	{
		return;
	}

	vec2 tc = vec2(float(texelCoord.x) / float(ScreenWidth), float(texelCoord.y) / float(ScreenHeight));

	vec3 focusDirLocal = vec3((tc - 0.5) * ViewParams.xy, ViewParams.z);

	Ray ray = Ray(
		vec3(CamToWorld[0].w, CamToWorld[1].w, CamToWorld[2].w),
		normalize((CamToWorld * vec4(focusDirLocal, 1.0)).xyz),
		1.0 / normalize((CamToWorld * vec4(focusDirLocal, 1.0)).xyz)
	);

	uint seed = uint(floor(
		tc.y * ScreenHeight * ScreenWidth
		+ tc.x * ScreenWidth)
	);

	vec4 pixel = vec4(Trace(ray, seed), 1.0);

	imageStore(OutTexture, texelCoord, pixel);
}