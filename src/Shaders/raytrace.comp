#version 460 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct Ray
{
	vec3 origin;
	vec3 dir;
	vec3 invDir;
};

struct RayTracingMaterial
{
	vec3 diffuseColor;
	vec3 specularColor;
	float shininess;
	float specularProbability;

	vec3 emissionColor;
	float emissionStrength;

	float refractionProbability;
	float refractionCoefficient;
};

struct RayHitInfo
{
	bool didHit;
	float dst;
	vec3 hitPoint;
	vec3 normal;
	RayTracingMaterial material;
};

sampler2D Texture;

vec3 Trace(Ray ray, inout uint seed)
{
	vec3 incommingLight = vec3(0);
	vec3 rayColor = vec3(1);

	for (int i = 0; i <= MaxBounces; ++i)
	{
		RayHitInfo info = RayCollision(ray);

		if (info.didHit)
		{
			ray.origin = info.hitPoint;

			// Directions
			vec3 diffuseDirection = normalize(info.normal + RandomDirection(seed));
			vec3 specularDirection = normalize(reflect(ray.dir, info.normal));

			// Specular flag
			RayTracingMaterial material = info.material;

			float randomValue = RandomFloat(seed);
			bool isSpecular = (material.shininess == 0.0)
			? false
			: randomValue <= material.specularProbability;

			// Refraction flag
			randomValue = RandomFloat(seed);
			bool isRefracted = (material.refractionProbability == 0.0)
			? false
			: randomValue <= material.refractionProbability;

			// Direction calculation
			if (isRefracted && material.refractionCoefficient <= 1)
			{
				float cos_theta = min(dot(-ray.dir, info.normal), 1.0);
				vec3 outPerp = material.refractionCoefficient * (ray.dir + cos_theta * info.normal);

				float outPerpLen = dot(outPerp, outPerp);
				vec3 outParallel = sqrt(abs(1.0 - outPerpLen)) * info.normal * -1.0;
				ray.dir = normalize(outPerp + outParallel);
				ray.origin += 0.1 * ray.dir;
				info.normal *= -1.0;
			}
			else
			{
				ray.dir = (isSpecular)
				? mix(diffuseDirection, specularDirection, info.material.shininess)
				: diffuseDirection;
			}

			vec3 emittedLight = material.emissionColor * material.emissionStrength;
			float lightStrength = dot(info.normal, ray.dir);
			incommingLight += emittedLight * rayColor;
			rayColor *= ((isSpecular || isRefracted) ? material.specularColor : material.diffuseColor) * lightStrength;
		}
		else
		{
			incommingLight += rayColor * vec3(0.308, 0.355, 0.375);
			break;
		}
	}

	return incommingLight;
}

void main()
{

}
