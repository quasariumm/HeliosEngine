#version 460
#extension GL_ARB_shading_language_include : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D OutTexture;
uniform uint ScreenWidth;
uniform uint ScreenHeight;

uniform mat4 CamToWorld;
uniform vec3 ViewParams;

uniform uint Frame = 0;

uniform bool ClearAccumulator = false;

#include "/Engine/Core/common.glsl"
#include "/Engine/Core/random.glsl"
#include "/Engine/Raytracing/ray.glsl"
#include "/Engine/Raytracing/materials.glsl"
#include "/Engine/Raytracing/intersections.glsl"
#include "/Engine/Raytracing/lighting.glsl"

const vec3 GroundColor  = vec3(0.5, 0.8, 0.3);
const vec3 HorizonColor = vec3(0.5, 0.7, 1.0);
const vec3 ZenithColor  = vec3(0.2, 0.6, 1.0);

const vec3 SunDirection		= normalize(vec3(1.0, -1.0, 0.0));
const float SunFocus    	= 150.0;
const float SunIntensity	= 3.0;
vec3 GetSkyboxColor(in Ray ray)
{
	float skyGradientT = pow(smoothstep(0.0, 0.4, ray.dir.y), 0.35);
	vec3 skyGradient = mix(HorizonColor, ZenithColor, skyGradientT);
	float sun = pow(max(0.0, dot(ray.dir, -SunDirection)), SunFocus) * SunIntensity;

	float groundToSkyT = smoothstep(-0.01, 0.0, ray.dir.y);
	float sunMask = 0.0;
	if (groundToSkyT >= 1.0)
		sunMask = 1.0;
	return mix(GroundColor, skyGradient, groundToSkyT) + sun * sunMask;
}

vec3 Trace(Ray ray, uint seed)
{
	vec3 incommingLight = vec3(0);
	vec3 rayColor = vec3(1);

	for (int i = 0; i <= 3; ++i)
	{
		RayHitInfo info = RayCollision(ray);
		info.lightVector = normalize(-sun.direction);

		if (info.didHit)
		{
			vec3 emittance = info.material.emissionColor * info.material.emissionStrength;

			vec3 light = SampleDirectionalLight(sun, info.hitPoint, info.normal);

			// Shadow ray
			Ray shadowRay = Ray(
				info.hitPoint + 0.001 * info.normal,
				-sun.direction,
				1.0 / -sun.direction
			);
			RayHitInfo shadowInfo = RayCollision(shadowRay);
			light *= float(!shadowInfo.didHit);

			vec3 BRDF = GetBRDFAndBounce(info.material, ray, seed, info);
			float PDF = GetPDF(info.material, info.normal, -ray.dir, info.lightVector);

			incommingLight += emittance + (BRDF * light) / PDF * rayColor;

			rayColor *= mix(info.material.diffuseColor, info.material.specularColor, info.material.specularity)
				* mix(light, vec3(1.0), info.material.specularity);

			ray.origin = info.hitPoint + 0.001 * ray.dir;
		}
		else
		{
			incommingLight += rayColor * GetSkyboxColor(ray);
			break;
		}
	}

	return incommingLight;
}

uint WangHash(in uint seed)
{
	// Wang hash initialisation
	seed = (seed ^ 61u) ^ (seed >> 16u);
	seed *= 9u, seed = seed ^ (seed >> 4u);
	seed *= 0x27d4eb2du;
	seed = seed ^ (seed >> 15u);
	return seed;
}

void main()
{
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

	if (texelCoord.x >= ScreenWidth || texelCoord.y >= ScreenHeight)
	{
		return;
	}

	vec2 tc = vec2(float(texelCoord.x) / float(ScreenWidth), float(texelCoord.y) / float(ScreenHeight));

	vec3 focusDirLocal = vec3((tc - 0.5) * ViewParams.xy, ViewParams.z);
	vec3 focusDir = normalize((CamToWorld * vec4(focusDirLocal, 1.0)).xyz);
	Ray ray = Ray(
		vec3(CamToWorld[0].w, CamToWorld[1].w, CamToWorld[2].w),
		focusDir,
		1.0 / focusDir
	);

	uint seed = uint(floor(tc.y * ScreenHeight * ScreenWidth + tc.x * ScreenWidth));
	seed ^= WangHash(Frame);
	seed = WangHash(seed);

	vec4 pixel = vec4(Trace(ray, seed), 1.0);
	pixel = max(pixel, vec4(0.0, 0.0, 0.0, 1.0));
	if (!ClearAccumulator)
	{
		vec4 accumulatorTexel = imageLoad(OutTexture, texelCoord);
		if (accumulatorTexel.a > 0.0)
		{
			pixel = 0.5 * pixel + 0.5 * accumulatorTexel;
			pixel.a = 1.0;
		}
	}

	imageStore(OutTexture, texelCoord, pixel);
}